@using SteelEstimation.Core.Services
@using SteelEstimation.Core.Configuration
@using SteelEstimation.Core.Entities
@using SteelEstimation.Infrastructure.Data
@using Microsoft.AspNetCore.Components.Authorization
@using Microsoft.EntityFrameworkCore
@using Microsoft.Extensions.Options
@inject ITimeTrackingService TimeTrackingService
@inject AuthenticationStateProvider AuthStateProvider
@inject ILogger<TimeTracker> Logger
@inject IOptions<TimeTrackerSettings> TimeTrackerSettings
@inject IDbContextFactory<ApplicationDbContext> DbContextFactory
@inject IJSRuntime JSRuntime
@implements IDisposable

@if (_isVisible)
{
    <div class="time-tracker @(_isPaused ? "paused" : "active") @(_isOvertime ? "overtime" : "") @(_isStopped ? "stopped" : "")">
        <div class="d-flex align-items-center gap-2">
            <i class="fas @(_isStopped ? "fa-stop-circle" : (_isPaused ? "fa-pause-circle" : "fa-clock")) @(_isStopped ? "text-secondary" : (_isPaused ? "text-warning" : (_isOvertime ? "text-danger" : "text-primary")))"></i>
            <div>
                <div class="time-display">@FormatTime(_currentSessionTime)</div>
                <div class="time-label">@(_isStopped ? "Stopped" : (_isPaused ? "Paused" : "Active"))</div>
            </div>
            @if (_totalTime != _currentSessionTime)
            {
                <div class="ms-2 border-start ps-2">
                    <div class="time-display-small">@FormatTime(_totalTime)</div>
                    <div class="time-label">Total</div>
                </div>
            }
            @if (_settings.ShowExpectedTime && _estimatedHours.HasValue && _estimatedHours.Value > 0)
            {
                <div class="ms-2 border-start ps-2">
                    <div class="time-display-small @(_isOvertime ? "text-danger" : "")">@FormatHours(_estimatedHours.Value)</div>
                    <div class="time-label">Expected</div>
                </div>
            }
            @if (_settings.ShowOvertime && _isOvertime && _overtimeHours > 0)
            {
                <div class="ms-2 border-start ps-2">
                    <div class="time-display-small text-danger">+@FormatHours(_overtimeHours)</div>
                    <div class="time-label">Overtime</div>
                </div>
            }
            
            <!-- Control Buttons -->
            <div class="ms-auto d-flex gap-1">
                @if (!_isStopped)
                {
                    @if (_isPaused)
                    {
                        <button class="btn btn-sm btn-outline-primary" @onclick="ResumeAsync" title="Resume Timer">
                            <i class="fas fa-play"></i>
                        </button>
                    }
                    else
                    {
                        <button class="btn btn-sm btn-outline-warning" @onclick="PauseAsync" title="Pause Timer">
                            <i class="fas fa-pause"></i>
                        </button>
                    }
                    <button class="btn btn-sm btn-outline-danger" @onclick="StopAsync" title="Stop Timer">
                        <i class="fas fa-stop"></i>
                    </button>
                }
                else
                {
                    <button class="btn btn-sm btn-outline-success" @onclick="StartNewSessionAsync" title="Start New Session">
                        <i class="fas fa-play"></i> Start
                    </button>
                }
            </div>
        </div>
    </div>
}
}

<style>
    .time-tracker {
        background-color: #f8f9fa;
        border: 1px solid #dee2e6;
        border-radius: 0.375rem;
        padding: 0.5rem 1rem;
        font-family: monospace;
        transition: all 0.3s ease;
    }
    
    .time-tracker.paused {
        background-color: #fff3cd;
        border-color: #ffeaa7;
    }
    
    .time-tracker.active {
        background-color: #e7f3ff;
        border-color: #b8daff;
    }
    
    .time-tracker.overtime {
        background-color: #ffe4e6;
        border-color: #ffb3ba;
    }
    
    .time-tracker.stopped {
        background-color: #e9ecef;
        border-color: #adb5bd;
    }
    
    .time-display {
        font-size: 1.1rem;
        font-weight: 600;
        color: #212529;
    }
    
    .time-display-small {
        font-size: 0.9rem;
        font-weight: 600;
        color: #495057;
    }
    
    .time-label {
        font-size: 0.75rem;
        color: #6c757d;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    }
</style>

@code {
    [Parameter] public int EstimationId { get; set; }
    [Parameter] public string? PageName { get; set; }
    [Parameter] public EventCallback<bool> OnPausedChanged { get; set; }
    [Parameter] public EventCallback<bool> OnStoppedChanged { get; set; }
    
    private Timer? _timer;
    private TimeSpan _currentSessionTime;
    private TimeSpan _totalTime;
    private bool _isPaused;
    private bool _isStopped;
    private bool _isVisible;
    private int? _userId;
    private Guid _sessionId;
    private TimeTrackerSettings _settings = new();
    private decimal? _estimatedHours;
    private bool _isOvertime;
    private decimal _overtimeHours;
    
    protected override async Task OnInitializedAsync()
    {
        try
        {
            Logger.LogInformation($"TimeTracker initializing with EstimationId: {EstimationId}, PageName: {PageName}");
            
            // If EstimationId is 0 or negative, don't show the tracker
            if (EstimationId <= 0)
            {
                Logger.LogInformation("TimeTracker hidden - EstimationId is 0 or negative");
                _isVisible = false;
                return;
            }
            
            _settings = TimeTrackerSettings.Value;
            
            if (!_settings.Enabled || !_settings.ShowTimer)
            {
                _isVisible = false;
                return;
            }
            
            var authState = await AuthStateProvider.GetAuthenticationStateAsync();
            
            if (authState.User.Identity?.IsAuthenticated == true)
            {
                // Get user ID from claims - try both UserId and NameIdentifier
                var userIdClaim = authState.User.FindFirst("UserId")?.Value ?? 
                                 authState.User.FindFirst(System.Security.Claims.ClaimTypes.NameIdentifier)?.Value;
                
                if (int.TryParse(userIdClaim, out var userId))
                {
                    _userId = userId;
                    
                    // Validate project exists before showing tracker
                    using var dbContext = await DbContextFactory.CreateDbContextAsync();
                    var project = await dbContext.Projects
                        .AsNoTracking()
                        .FirstOrDefaultAsync(p => p.Id == EstimationId);
                    
                    // If project doesn't exist, don't try to track time
                    if (project == null)
                    {
                        Logger.LogWarning($"Project with ID {EstimationId} not found. Time tracking disabled.");
                        _isVisible = false;
                        return;
                    }
                    
                    _estimatedHours = project.EstimatedHours;
                    _isVisible = true;
                    
                    try
                    {
                        // Start or get existing session
                        var session = await TimeTrackingService.GetActiveSessionAsync(EstimationId, userId);
                        if (session == null)
                        {
                            session = await TimeTrackingService.StartSessionAsync(EstimationId, userId, PageName);
                        }
                        _sessionId = session.SessionId;
                    }
                    catch (InvalidOperationException ex)
                    {
                        Logger.LogWarning(ex, "Failed to start time tracking session");
                        _isVisible = false;
                        return;
                    }
                    
                    // Get initial times
                    await UpdateTimes();
                    
                    // Start timer to update display
                    _timer = new Timer(UpdateDisplay, null, TimeSpan.Zero, TimeSpan.FromSeconds(1));
                }
                else
                {
                    _isVisible = false;
                }
            }
            else
            {
                _isVisible = false;
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error initializing TimeTracker");
            _isVisible = false;
        }
    }
    
    private async void UpdateDisplay(object? state)
    {
        await InvokeAsync(async () =>
        {
            if (!_isPaused && !_isStopped && _userId.HasValue)
            {
                await UpdateTimes();
                StateHasChanged();
            }
        });
    }
    
    private async Task UpdateTimes()
    {
        if (_userId.HasValue)
        {
            _currentSessionTime = await TimeTrackingService.GetSessionTimeAsync(_sessionId);
            _totalTime = await TimeTrackingService.GetTotalTimeAsync(EstimationId, _userId);
            
            // Check if we're overtime
            if (_estimatedHours.HasValue && _estimatedHours.Value > 0)
            {
                var totalHours = (decimal)_totalTime.TotalHours;
                var threshold = _estimatedHours.Value * (decimal)_settings.OvertimeWarningThreshold;
                _isOvertime = totalHours >= threshold;
                _overtimeHours = Math.Max(0, totalHours - _estimatedHours.Value);
            }
        }
    }
    
    public async Task PauseAsync()
    {
        if (!_isPaused && _userId.HasValue)
        {
            _isPaused = true;
            await TimeTrackingService.PauseSessionAsync(EstimationId, _userId.Value);
            await OnPausedChanged.InvokeAsync(true);
            StateHasChanged();
        }
    }
    
    public async Task ResumeAsync()
    {
        if (_isPaused && _userId.HasValue)
        {
            _isPaused = false;
            await TimeTrackingService.ResumeSessionAsync(EstimationId, _userId.Value);
            
            // Get the new session ID
            var session = await TimeTrackingService.GetActiveSessionAsync(EstimationId, _userId.Value);
            if (session != null)
            {
                _sessionId = session.SessionId;
            }
            
            await OnPausedChanged.InvokeAsync(false);
            StateHasChanged();
        }
    }
    
    public async Task StopAsync()
    {
        if (!_isStopped && _userId.HasValue)
        {
            // Ask for confirmation
            var confirmed = await JSRuntime.InvokeAsync<bool>("confirm", 
                "Are you sure you want to stop the timer? This will end your current session.");
            
            if (!confirmed)
                return;
                
            try
            {
                // Find the current session
                using var dbContext = await DbContextFactory.CreateDbContextAsync();
                var currentSession = await dbContext.EstimationTimeLogs
                    .FirstOrDefaultAsync(log => log.EstimationId == EstimationId 
                                              && log.UserId == _userId.Value 
                                              && log.EndTime == null);
                
                if (currentSession != null)
                {
                    await TimeTrackingService.EndSessionAsync(currentSession.Id);
                }
                
                _isStopped = true;
                _isPaused = false;
                
                // Stop the timer
                _timer?.Dispose();
                _timer = null;
                
                // Final update of times
                await UpdateTimes();
                
                await OnPausedChanged.InvokeAsync(false);
                await OnStoppedChanged.InvokeAsync(true);
                StateHasChanged();
                
                Logger.LogInformation("Timer stopped manually for estimation {EstimationId} by user {UserId}", EstimationId, _userId);
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error stopping timer for estimation {EstimationId} by user {UserId}", EstimationId, _userId);
            }
        }
    }
    
    public async Task StartNewSessionAsync()
    {
        if (_isStopped && _userId.HasValue)
        {
            try
            {
                // Start a new session
                var session = await TimeTrackingService.StartSessionAsync(EstimationId, _userId.Value, PageName);
                _sessionId = session.SessionId;
                
                _isStopped = false;
                _isPaused = false;
                
                // Reset session time but keep total time
                _currentSessionTime = TimeSpan.Zero;
                await UpdateTimes();
                
                // Start timer to update display
                _timer = new Timer(UpdateDisplay, null, TimeSpan.Zero, TimeSpan.FromSeconds(1));
                
                await OnStoppedChanged.InvokeAsync(false);
                StateHasChanged();
                
                Logger.LogInformation("New timer session started for estimation {EstimationId} by user {UserId}", EstimationId, _userId);
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error starting new timer session for estimation {EstimationId} by user {UserId}", EstimationId, _userId);
            }
        }
    }
    
    private string FormatTime(TimeSpan time)
    {
        return $"{(int)time.TotalHours:00}:{time.Minutes:00}:{time.Seconds:00}";
    }
    
    private string FormatHours(decimal hours)
    {
        var wholeHours = (int)hours;
        var minutes = (int)((hours - wholeHours) * 60);
        return $"{wholeHours:00}:{minutes:00}:00";
    }
    
    public void Dispose()
    {
        _timer?.Dispose();
    }
}